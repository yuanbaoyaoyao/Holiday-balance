{"version":3,"sources":["fireworks.node.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nfunction random(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst TAU = Math.PI * 2;\n\nclass Particle {\n    constructor({ isRocket = false, hue = random(1, 360), brightness = random(50, 60), position, }) {\n        this.isRocket = isRocket;\n        this.position = position;\n        this.positions = [this.position, this.position, this.position];\n        if (this.isRocket) {\n            this.velocity = {\n                x: random(-3, 3),\n                y: random(-7, -3),\n            };\n            this.shrink = 0.999;\n            this.resistance = 1;\n        }\n        else {\n            const angle = random(0, TAU);\n            const speed = Math.cos(random(0, TAU)) * 15;\n            this.velocity = {\n                x: Math.cos(angle) * speed,\n                y: Math.sin(angle) * speed,\n            };\n            this.shrink = random(0, 0.05) + 0.93;\n            this.resistance = 0.92;\n        }\n        this.gravity = 0.01;\n        this.size = 3;\n        this.alpha = 1;\n        this.fade = 0;\n        this.hue = hue;\n        this.brightness = brightness;\n    }\n    clone() {\n        return new Particle({\n            position: {\n                x: this.position.x,\n                y: this.position.y,\n            },\n            hue: this.hue,\n            brightness: this.brightness,\n        });\n    }\n    shouldRemove(cw, ch) {\n        if (this.alpha <= 0.1 || this.size <= 1) {\n            return true;\n        }\n        if (this.position.x > cw || this.position.x < 0) {\n            return true;\n        }\n        if (this.position.y > ch || this.position.y < 0) {\n            return true;\n        }\n        return false;\n    }\n    shouldExplode(maxHeight, minHeight, chance) {\n        if (!this.isRocket) {\n            return false;\n        }\n        if (this.position.y <= maxHeight) {\n            return true;\n        }\n        if (this.position.y >= minHeight) {\n            return false;\n        }\n        return random(0, 1) <= chance;\n    }\n    update() {\n        this.positions.pop();\n        this.positions.unshift({ x: this.position.x, y: this.position.y });\n        this.velocity.x *= this.resistance;\n        this.velocity.y *= this.resistance;\n        this.velocity.y += this.gravity;\n        this.position.x += this.velocity.x;\n        this.position.y += this.velocity.y;\n        this.size *= this.shrink;\n        this.alpha -= this.fade;\n    }\n    draw(ctx) {\n        const lastPosition = this.positions[this.positions.length - 1];\n        ctx.beginPath();\n        ctx.moveTo(lastPosition.x, lastPosition.y);\n        ctx.lineTo(this.position.x, this.position.y);\n        ctx.lineWidth = this.size;\n        ctx.lineCap = 'round';\n        ctx.strokeStyle = `hsla(${this.hue}, 100%, ${this.brightness}%, ${this.alpha})`;\n        ctx.stroke();\n    }\n}\n\nclass Things {\n    constructor({ maxRockets, numParticles, cw, ch, rocketInitialPoint, cannons, }) {\n        this._set = new Set();\n        this.rockets = 0;\n        this.maxRockets = maxRockets;\n        this.numParticles = numParticles;\n        this.cw = cw;\n        this.ch = ch;\n        this.rocketInitialPoint = rocketInitialPoint;\n        this.cannons = cannons;\n        if (this.rocketInitialPoint) {\n            this.cannons.push({ x: this.rocketInitialPoint, y: this.ch });\n        }\n    }\n    size() {\n        return this._set.size;\n    }\n    entries() {\n        return this._set;\n    }\n    clear() {\n        this._set.clear();\n        this.rockets = 0;\n    }\n    delete(thing) {\n        this._set.delete(thing);\n        if (thing.isRocket)\n            this.rockets--;\n    }\n    add(thing) {\n        this._set.add(thing);\n    }\n    explode(particle) {\n        for (let i = 0; i < this.numParticles; i += 1) {\n            this.add(particle.clone());\n        }\n        this.delete(particle);\n    }\n    spawnRocket() {\n        this.rockets++;\n        const cannonIndex = Math.floor(random(0, this.cannons.length));\n        const cannon = this.cannons[cannonIndex] || {};\n        this.add(new Particle({\n            isRocket: true,\n            position: Object.assign(Object.assign(Object.assign({}, cannon), (cannon.x == null && { x: random(0, this.cw) })), (cannon.y == null && { y: this.ch })),\n        }));\n    }\n    spawnRockets() {\n        if (this.rockets < this.maxRockets) {\n            this.spawnRocket();\n        }\n    }\n}\n\nclass Fireworks {\n    constructor(container, { rocketSpawnInterval = 150, maxRockets = 3, numParticles = 100, explosionMinHeight = 0.2, explosionMaxHeight = 0.9, explosionChance = 0.08, width = container.clientWidth, height = container.clientHeight, rocketInitialPoint = null, cannons = [], } = {}) {\n        this.finishCallbacks = [];\n        this.container = container;\n        this.rocketSpawnInterval = rocketSpawnInterval;\n        this.maxRockets = maxRockets;\n        this.cw = width;\n        this.ch = height;\n        this.maxH = this.ch * (1 - explosionMaxHeight);\n        this.minH = this.ch * (1 - explosionMinHeight);\n        this.chance = explosionChance;\n        this.pixelRatio = window.devicePixelRatio || 1;\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        container.appendChild(this.canvas);\n        this.things = new Things({\n            maxRockets: this.maxRockets,\n            numParticles,\n            cw: this.cw,\n            ch: this.ch,\n            rocketInitialPoint,\n            cannons,\n        });\n        this.updateDimensions();\n    }\n    destroy() {\n        this.canvas.parentElement.removeChild(this.canvas);\n        window.clearInterval(this.interval);\n        window.cancelAnimationFrame(this.rafInterval);\n    }\n    start() {\n        if (this.interval != null)\n            return;\n        this.interval = window.setInterval(() => this.things.spawnRockets(), this.rocketSpawnInterval);\n        this.rafInterval = window.requestAnimationFrame(() => this.update());\n        return () => this.stop();\n    }\n    updateDimensions() {\n        this.canvas.width = this.cw * this.pixelRatio;\n        this.canvas.height = this.ch * this.pixelRatio;\n        this.canvas.style.width = `${this.cw}px`;\n        this.canvas.style.height = `${this.ch}px`;\n        this.ctx.scale(this.pixelRatio, this.pixelRatio);\n        this.things.cw = this.cw;\n        this.things.ch = this.ch;\n    }\n    setSize(width, height) {\n        this.cw = width;\n        this.ch = height;\n        this.updateDimensions();\n    }\n    resetSize() {\n        this.cw = this.container.clientWidth;\n        this.ch = this.container.clientHeight;\n        this.updateDimensions();\n    }\n    stop() {\n        window.clearInterval(this.interval);\n        this.interval = null;\n    }\n    kill() {\n        this.things.clear();\n        this.stop();\n        window.cancelAnimationFrame(this.rafInterval);\n        this._finish();\n    }\n    fire() {\n        this.things.spawnRocket();\n        if (!this.rafInterval) {\n            this.rafInterval = window.requestAnimationFrame(() => this.update());\n        }\n    }\n    onFinish(cb) {\n        this.finishCallbacks.push(cb);\n    }\n    _clear(force = false) {\n        this.ctx.globalCompositeOperation = 'destination-out';\n        this.ctx.fillStyle = `rgba(0, 0, 0 ${force ? '' : ', 0.5'})`;\n        this.ctx.fillRect(0, 0, this.cw, this.ch);\n        this.ctx.globalCompositeOperation = 'lighter';\n    }\n    _finish() {\n        this._clear(true);\n        this.rafInterval = null;\n        this.finishCallbacks.forEach((cb) => cb());\n    }\n    update() {\n        this._clear();\n        for (const particle of this.things.entries()) {\n            particle.draw(this.ctx);\n            particle.update();\n            if (particle.shouldRemove(this.cw, this.ch)) {\n                this.things.delete(particle);\n            }\n            else if (particle.shouldExplode(this.maxH, this.minH, this.chance)) {\n                this.things.explode(particle);\n            }\n        }\n        if (this.interval || this.things.size() > 0) {\n            this.rafInterval = window.requestAnimationFrame(() => this.update());\n        }\n        else {\n            this._finish();\n        }\n    }\n}\n\nmodule.exports = Fireworks;\n"]}