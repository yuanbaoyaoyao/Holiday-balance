{"version":3,"sources":["lunar_calendar.js","utils.js","solar_term.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const { base64ToBit, checkDate } = require('./utils');\r\nconst { getSolarTerm } = require('./solar_term');\r\n\r\nconst table = [];\r\nconst heavenlyStemStr = '甲乙丙丁戊己庚辛壬癸';\r\nconst earthlyBranchStr = '子丑寅卯辰巳午未申酉戌亥';\r\nconst zodiacStr = '鼠牛虎兔龙蛇马羊猴鸡狗猪';\r\nconst lunarMonthStr = '正二三四五六七八九十冬腊';\r\nconst nubmerStr = '一二三四五六七八九十';\r\n\r\nfunction decompressData() {\r\n    const base64Str = 'hLaCVwUrqpNDSYNlUaqgrUE1pJXQSuak2FJoaSrqlC1QNailtBK26TcElwpLWyWDUoNqJW1ArYJVySXgkuzJYNSg6lVtSC1oFbHJuCS58loZKhqU20oLVQVqSq2BLoSWlkrCpV7SoNlBaqqrUE2gpbNSuClcVKg6VBqpq1QVaglslK4KVwUmPpMGyrrVQVqCW1UroJWhSamk0NJY1ShaoFtTS2glbBJtKS4Ul1ZLBqUG1GraBVsEq6pLwSXBks2pQdSw1lBawKtlk2hJcGSyalQ1KDaUlqoK1PVbAl0JLVyVhUqFpSWqgrVlVqCXQUtspXBSsKk0dKg1UFapJtQS2alcFJwaTL0mDVMFqja1BLbaV0ErQpNbSWGkoapLtUC1oFbSStgk29JcKSwqlW1KDaQVtGq2CTeEl4JLgyWzUoOpQaqSrYFVwSXHkuDJZ9SoalBtKq1UFagptRS6ClsVKwqVC0prVQVqgq0lLoKWwUrOpODSbuUwaqCtVU2oJbBSuik4NFo6TBqkG1TNagVtBK5KToUWhoqWyUNUg';\r\n    const bitStr = base64ToBit(base64Str);\r\n    let solarDate = { y: 1900, m: 1, d: 31, obj: new Date(1900, 0, 31, 0, 0, 0, 0) };\r\n    let heavenlyStem = 6; // 天干\r\n    let earthlyBranch = 0; // 地支\r\n    for (let i = 0; i < bitStr.length; ) {\r\n        if (i + 16 >= bitStr.length) {\r\n            break;\r\n        }\r\n        const head = bitStr.substr(i, 4);\r\n        i += 4;\r\n        const leapMonth = +`0b${head}`;\r\n        const monthCount = leapMonth > 0 ? 13 : 12;\r\n        const months = bitStr.substr(i, monthCount).split('').map(o => +o);\r\n        i += monthCount;\r\n\r\n        table.push({\r\n            solarDate,\r\n            leapMonth,\r\n            months,\r\n            heavenlyStem,\r\n            earthlyBranch\r\n        });\r\n\r\n        const dateCount = monthCount*29 + months.filter(o => o == 1).length;\r\n        const newSolarDate = new Date(solarDate.y, solarDate.m - 1, solarDate.d + dateCount, 0, 0, 0, 0);\r\n        solarDate = {\r\n            y: newSolarDate.getFullYear(),\r\n            m: newSolarDate.getMonth() + 1,\r\n            d: newSolarDate.getDate(),\r\n            obj: newSolarDate\r\n        };\r\n        heavenlyStem = (heavenlyStem + 1) % 10;\r\n        earthlyBranch = (earthlyBranch + 1) % 12;\r\n    }\r\n}\r\n\r\ndecompressData();\r\n\r\nfunction isBefore(base, target) {\r\n    if (base.y != target.y) {\r\n        return base.y > target.y;\r\n    } else if (base.m != target.m) {\r\n        return base.m > target.m;\r\n    } else if (base.d != target.d) {\r\n        return base.d > target.d;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction getLunarStr(month, date, isLeap) {\r\n    const monthStr = `${isLeap ? '闰' : ''}${lunarMonthStr[month - 1]}月`;\r\n    if (date <= 10) {\r\n        return `${monthStr}初${nubmerStr[date - 1]}`;\r\n    } else if (date < 20) {\r\n        return `${monthStr}十${nubmerStr[date - 11]}`;\r\n    } else if (date == 20) {\r\n        return `${monthStr}廿十`;\r\n    } else if (date > 20) {\r\n        return `${monthStr}廿${nubmerStr[date - 21]}`;\r\n    } else {\r\n        return `${monthStr}三十`;\r\n    }\r\n}\r\n\r\nfunction getLunar(year, month, date) {\r\n    year = Math.floor(+year);\r\n    month = Math.floor(+month);\r\n    date = Math.floor(+date);\r\n    checkDate(year, month, date);\r\n    let index = year - 1900;\r\n    let row = table[index];\r\n    if (isBefore(row.solarDate, { y: year, m: month, d: date })) {\r\n        index -= 1;\r\n        row = table[index];\r\n    }\r\n    if (!row) {\r\n        throw new Error('Invalid Date');\r\n    }\r\n    const targetDate = new Date(year, month - 1, date, 0, 0, 0, 0);\r\n    let delta = Math.round((targetDate.getTime() - row.solarDate.obj.getTime()) / (24*60*60*1000));\r\n    let afterLeap = false;\r\n    for(let i = 0; i < row.months.length; i++) {\r\n        const isLeap = row.leapMonth > 0 && i == row.leapMonth;\r\n        if (isLeap) {\r\n            afterLeap = true;\r\n        }\r\n        const days = 29 + row.months[i];\r\n        if (delta < days) {\r\n            let lunarMonth = afterLeap ? i : i + 1;\r\n            return {\r\n                lunarMonth,\r\n                lunarDate: delta + 1,\r\n                isLeap,\r\n                solarTerm: getSolarTerm(year, month, date),\r\n                lunarYear: `${heavenlyStemStr[row.heavenlyStem]}${earthlyBranchStr[row.earthlyBranch]}年`,\r\n                zodiac: `${zodiacStr[row.earthlyBranch]}`,\r\n                dateStr: getLunarStr(lunarMonth, delta + 1, isLeap)\r\n            };\r\n        } else {\r\n            delta -= days;\r\n        }\r\n    }\r\n    throw new Error(`There's something wrong!`);\r\n}\r\n\r\nmodule.exports = { getLunar };\r\n","function base64ToBit(base64Str) {\r\n    const base64CodeMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n    const result = [];\r\n    for (let i = 0; i < base64Str.length; i++) {\r\n        let n = base64CodeMap.indexOf(base64Str[i]);\r\n        result.push(n.toString(2).padStart(6, '0'));\r\n    }\r\n    return result.join('');\r\n}\r\n\r\nfunction checkDate(year, month, date) {\r\n    if (year < 1901 || year > 2100) {\r\n        throw new Error('Invalid Year');\r\n    }\r\n    if (month < 1 || month > 12) {\r\n        throw new Error('Invalid Month');\r\n    }\r\n    if (date < 1 || date > 31) {\r\n        throw new Error('Invalid Date');\r\n    }\r\n    if ([4, 6, 9, 11].indexOf(month) != -1 && date > 30) {\r\n        throw new Error('Invalid Date');\r\n    }\r\n    if (month == 2) {\r\n        if (date > 29) {\r\n            throw new Error('Invalid Date');\r\n        } else {\r\n            let isLeap = false;\r\n            if (year % 400 == 0) {\r\n                isLeap = true\r\n            } else if (year % 4 == 0 && year % 100 != 0) {\r\n                isLeap = true;\r\n            }\r\n            if (!isLeap && date > 28) {\r\n                throw new Error('Invalid Date');\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    base64ToBit,\r\n    checkDate,\r\n};","const { base64ToBit, checkDate } =  require('./utils');\r\n\r\n// 2bit代表日期 共48bit\r\n// 48bit -> base64  8个\r\n// 200年一共68种情况\r\nconst names = ['小寒', '大寒', '立春', '雨水', '惊蛰', '春分', '清明', '谷雨', '立夏', '小满', '芒种',\r\n    '夏至', '小暑', '大暑', '立秋', '处暑', '白露', '秋分', '寒露', '霜降', '立冬', '小雪', '大雪', '冬至'];\r\nconst baseDate = [4, 19, 3, 18, 4, 19, 4, 19, 4, 20, 4, 20, 6, 22, 6, 22, 6, 22, 7, 22, 6, 21, 6, 21];\r\n\r\nconst table = [];\r\n\r\nfunction decompressData() {\r\n    const codeStr = 'ABCDAECDAECDFGHIJKHILKMILABNOABNOAENOAENOAEPQRGSTUGSTLAVTOAWXOAWXOAYXOAYZOabcdebcQUfgThijkOilXOimXOimXOimcOnocdpqcQrsgktujkvumXvumXvumcvumcvwocxyqcz0sj10s213u243um43um53wm56wq567q589s+/0s~/3u~!3u@#3um';\r\n    const groupsStr = 'paaqmqqpqaquqqqqqvruruqq6qWaWZqlqaqqqqqqlaaqmqqppaaqqqqqqrququqqqqWaWZaVlaaampqlpaaqqqqplaWampqlqaququqqqqWZWZVVlaWaWZqlqqVZWZVVlaWaWZaVlaaqmpqpqmVZVZVVVaWaWZaVlaWampqpqlVZVZVVqVVZVVVVVaWZWZVVqVVVVVVVVaVZWZVVpaaqmpqpqVFVVVVVVaVZVZVVlaWaWZalpaaampqppVFVRVVVVWVZVZVVlaWaWpqlpVFVRVVUVVVZVVVVVaWZWZaVVFVZVVVVVFVVVVVVpVFVRUVUVFFVVVVVpVFFRUVUVFFVRVVVlVBFRUVUUFFVRVVVlVBFBEVUUFFVRVVUlVBFBEVQUFFFRUVUlVBFBEFQUFBFRUVUlVBEBEFAQFBFBEVUVVBEBEFAVVVVVVVVQFBFBEVQVVBEBEAAVVAEAEAAQFBFBEFQUFBFBUVUQFBEBEFAUFBFBEVUVQAEAAAAAFBEBEFAVQAAAAAAAFBEBEAAVAAAAAAAAFBEAEAA';\r\n    const groups = [];\r\n    for (let i = 0; i < groupsStr.length; i += 8) {\r\n        const groupBitStr = base64ToBit(groupsStr.substr(i, 8));\r\n        const group = [];\r\n        for (let j = 0; j < groupBitStr.length; j += 2) {\r\n            group.push(+`0b${groupBitStr.substr(j, 2)}`);\r\n        }\r\n        groups.push(group);\r\n    }\r\n    const codeMapStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/~!@#';\r\n    for (let i = 0; i < codeStr.length; i++) {\r\n        table.push(groups[codeMapStr.indexOf(codeStr[i])]);\r\n    }\r\n}\r\n\r\ndecompressData();\r\n\r\nfunction getSolarTerm(year, month, date) {\r\n    year = Math.floor(+year);\r\n    month = Math.floor(+month);\r\n    date = Math.floor(+date);\r\n    checkDate(year, month, date);\r\n    const index = (month - 1) * 2 + (date < 15 ? 0 : 1);\r\n    const d = baseDate[index] + table[year - 1901][index];\r\n    if (date == d) {\r\n        return names[index];\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nmodule.exports = { getSolarTerm };\r\n"]}